!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Peer=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var util = require('./util');
var Negotiator = require('./negotiator');
var EventEmitter = require('eventemitter3');
var BinaryPack = require('./binarypack');
var Socket = require('./socket');
var MediaConnection = require('./mediaconnection');
var DataConnection = require('./dataconnection');
var Log = require('./log');

/**
 * A peer who can initiate connections with other peers.
 * @param {string} id - The ID of the peer
 * @param {Object} options - Optional arguments for the connection
 * @param {string} options.key - The API key
 * @param {Object} options.config - Configuration hash
 * @param {Function} options.debug - Debug function, 0,1,2,3
 */
function Peer(id, options) {
  if (!(this instanceof Peer)) {
    return new Peer(id, options);
  }

  EventEmitter.call(this);

  // Deal with overloading
  if (typeof id === 'object' || !id) {
    options = id;
    id = undefined;
  }

  // Check for HTTPS
  var isSecure;
  if (typeof location !== 'undefined') {
    isSecure = location.protocol === 'https:';
  }

  // Configuration
  options = util.extend({
    debug: 0, // 0: Disabled, 1: Errors, 2: Warnings, 3: All logs
    host: util.CLOUD_HOST,
    port: util.CLOUD_PORT,
    path: '/',
    key: 'peerjs',
    token: util.randomToken(),
    config: util.defaultConfig,
    secure: isSecure,
    logFunction: function() {
      var copy = Array.prototype.slice.call(arguments).join(' ');
      console.log(copy);
    }
  }, options);

  this.options = options;

  // Detect relative URL host.
  if (options.host === '/') {
    options.host = window.location.hostname;
  }

  // Set path correctly.
  if (options.path[0] !== '/') {
    options.path = '/' + options.path;
  }
  if (options.path[options.path.length - 1] !== '/') {
    options.path += '/';
  }

  // Set custom log function.
  if (options.logFunction) {
    Log.setLogFunction(options.logFunction);
  }

  Log.logLevel = options.debug;

  this._id = id;
  this._lastServerId = id;
  this._options = options;
  this._open = false;
  this._connections = {};
  this._lostMessages = {};
  this._socket = null;
  this._mediaEngine = null;

  // Start the connection.
  this._initialize();
}

util.inherits(Peer, EventEmitter);

Peer.prototype._initialize = function() {
  var self = this;
  this._socket = new Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.token);
  this._socket.on('message', function(data) {
    self._handleMessage(data);
  });
  this._socket.on('error', function(error) {
    self.emit('error', error);
  });
  this._socket.on('disconnected', function() {
    self._open = false;
    self.emit('disconnected');
  });
  this._socket.on('close', function() {
    self._open = false;
    self.emit('close');
  });
  this._socket.start(this._id);
};

/** Get the ID for this peer */
Peer.prototype.id = function() {
  return this._id;
};

/** Get a list of connections for this peer */
Peer.prototype.connections = function() {
  return this._connections;
};

/**
 * Connects to a remote peer
 * @param {string} peer The peer ID
 * @param {Object} [options] Optional arguments
 * @return {DataConnection}
 */
Peer.prototype.connect = function(peer, options) {
  if (!this._open) {
    throw new Error('Cannot connect to remote peer before you are connected to the server. Wait for the "open" event.');
  }

  var connection = new DataConnection(peer, this, options);
  this._addConnection(connection);
  return connection;
};

/**
 * Calls a remote peer
 * @param {string} peer The peer ID
 * @param {MediaStream} stream The stream to send to the remote peer
 * @param {Object} [options] Optional arguments
 * @return {MediaConnection}
 */
Peer.prototype.call = function(peer, stream, options) {
  if (!this._open) {
    throw new Error('Cannot call remote peer before you are connected to the server. Wait for the "open" event.');
  }

  if (!stream) {
    throw new Error('Call requires a stream');
  }

  var connection = new MediaConnection(peer, this, options);
  connection.localStream = stream;
  this._addConnection(connection);
  return connection;
};

/**
 * Destroys the Peer and closes all connections */
Peer.prototype.destroy = function() {
  this._open = false;
  this.disconnect();
  this.emit('close');
};

/**
 * Disconnect from the server and close all connections */
Peer.prototype.disconnect = function() {
  this._socket.close();
  this._open = false;

  // Close all connections we have
  for (var peerId in this._connections) {
    var connections = this._connections[peerId];
    for (var i = 0, ii = connections.length; i < ii; i += 1) {
      connections[i].close();
    }
  }
  this._connections = {};
};

/** Add a data/media connection to this peer. */
Peer.prototype._addConnection = function(connection) {
  var connections = this._connections[connection.peer];
  if (!connections) {
    connections = this._connections[connection.peer] = [];
  }
  connections.push(connection);
};

/** Retrieve a data/media connection for this peer. */
Peer.prototype._getConnection = function(peer, connectionId) {
  var connections = this._connections[peer];
  if (!connections) {
    return null;
  }
  for (var i = 0, ii = connections.length; i < ii; i += 1) {
    if (connections[i].id === connectionId) {
      return connections[i];
    }
  }
  return null;
};

/** Handle a message from the server. */
Peer.prototype._handleMessage = function(message) {
  var type = message.type;
  var payload = message.payload;
  var peer = message.src;

  switch (type) {
    case 'OPEN':
      this._id = payload;
      this._lastServerId = payload;
      this._open = true;
      this.emit('open', this.id);
      break;
    case 'ERROR':
      this.emit('error', payload);
      break;
    case 'ID-TAKEN':
      this._lastServerId = this._id;
      this.disconnect();
      this.emit('error', 'ID "' + this._id + '" is taken');
      break;
    case 'INVALID-KEY':
      this.disconnect();
      this.emit('error', 'API key is invalid');
      break;
    case 'LEAVE':
      this._cleanupPeer(peer);
      break;
    case 'EXPIRE':
      this.emit('error', 'Could not connect to peer ' + peer);
      break;
    case 'OFFER':
      var connection = this._getConnection(peer, payload.connectionId);
      if (connection) {
        // connection already exists
        connection.handleMessage(message);
      } else {
        // new connection
        var isDataConnection = payload.type === 'data';
        var ConnectionClass = isDataConnection ? DataConnection : MediaConnection;
        var connection = new ConnectionClass(peer, this, {
          connectionId: payload.connectionId,
          metadata: payload.metadata,
          label: payload.label,
          serialization: payload.serialization,
          reliable: payload.reliable
        });
        this._addConnection(connection);
        connection.handleMessage(message);
      }
      break;
    default:
      var connection = this._getConnection(peer, payload.connectionId);
      if (connection) {
        connection.handleMessage(message);
      } else {
        // Save for possible later use
        if (!this._lostMessages[peer]) {
          this._lostMessages[peer] = [];
        }
        this._lostMessages[peer].push(message);
      }
      break;
  }
};

/** Remove a peer from this peer's connections. */
Peer.prototype._cleanupPeer = function(peer) {
  var connections = this._connections[peer];
  if (connections) {
    for (var i = 0, ii = connections.length; i < ii; i += 1) {
      connections[i].close();
    }
    delete this._connections[peer];
  }
  delete this._lostMessages[peer];
};

module.exports = Peer;

},{"./binarypack":2,"./dataconnection":3,"./eventemitter3":4,"./log":5,"./mediaconnection":6,"./negotiator":7,"./socket":9,"./util":10}],2:[function(require,module,exports){
(function (global){
// BinaryPack is a fork of msgpack-javascript that encodes to a Blob or
// ArrayBuffer when possible.
//
// This creates a global BinaryPack object.
//
// https://github.com/binarypack/binarypack
//

(function(global){

  var exports = global.BinaryPack = {};

  // only use native ArrayBuffer if we're in a real browser environment
  if (global.Blob && global.ArrayBuffer && global.Uint8Array) {
    exports.useNativeBuffer = true;
  } else {
    exports.useNativeBuffer = false;
  }

  exports.encode = function(data) {
    var encoded = [];
    encodeInternal(data, encoded);
    var totalLength = 0;
    for (var i = 0, ii = encoded.length; i < ii; i++) {
      totalLength += encoded[i].length || encoded[i].byteLength;
    }
    var uint8 = new Uint8Array(totalLength);
    var offset = 0;
    for (var i = 0, ii = encoded.length; i < ii; i++) {
      var part = encoded[i];
      uint8.set(part, offset);
      offset += part.length || part.byteLength;
    }
    return uint8.buffer;
  };

  exports.decode = function(buffer) {
    var data = new DataView(buffer);
    var offset = 0;
    return decodeInternal(data);
  };

  function decodeInternal(data) {
    var type = getUint8();
    switch(type) {
      case 0xc0: // nil
        return null;
      case 0xc2: // false
        return false;
      case 0xc3: // true
        return true;
      case 0xca: // float
        return getFloat32();
      case 0xcb: // double
        return getFloat64();
      case 0xcc: // uint8
        return getUint8();
      case 0xcd: // uint16
        return getUint16();
      case 0xce: // uint32
        return getUint32();
      case 0xcf: // uint64
        return getUint64();
      case 0xd0: // int8
        return getInt8();
      case 0xd1: // int16
        return getInt16();
      case 0xd2: // int32
        return getInt32();
      case 0xd3: // int64
        return getInt64();
      case 0xda: // raw16
        var length = getUint16();
        return getRawString(length);
      case 0xdb: // raw32
        var length = getUint32();
        return getRawString(length);
      case 0xdc: // array16
        var length = getUint16();
        var array = [];
        for (var i = 0; i < length; i++) {
          array.push(decodeInternal(data));
        }
        return array;
      case 0xdd: // array32
        var length = getUint32();
        var array = [];
        for (var i = 0; i < length; i++) {
          array.push(decodeInternal(data));
        }
        return array;
      case 0xde: // map16
        var length = getUint16();
        var map = {};
        for (var i = 0; i < length; i++) {
          var key = decodeInternal(data);
          map[key] = decodeInternal(data);
        }
        return map;
      case 0xdf: // map32
        var length = getUint32();
        var map = {};
        for (var i = 0; i < length; i++) {
          var key = decodeInternal(data);
          map[key] = decodeInternal(data);
        }
        return map;
      default:
        if (type < 0x80) { // positive fixnum
          return type;
        }
        if (type < 0x90) { // fixmap
          var length = type & 0x0f;
          var map = {};
          for (var i = 0; i < length; i++) {
            var key = decodeInternal(data);
            map[key] = decodeInternal(data);
          }
          return map;
        }
        if (type < 0xa0) { // fixarray
          var length = type & 0x0f;
          var array = [];
          for (var i = 0; i < length; i++) {
            array.push(decodeInternal(data));
          }
          return array;
        }
        if (type < 0xc0) { // fixraw
          var length = type & 0x1f;
          return getRawString(length);
        }
        if (type >= 0xe0) { // negative fixnum
          return type - 0x100;
        }
        throw new Error('Unknown type 0x' + type.toString(16));
    }
    function getUint8() {
      var value = data.getUint8(offset);
      offset += 1;
      return value;
    }
    function getUint16() {
      var value = data.getUint16(offset);
      offset += 2;
      return value;
    }
    function getUint32() {
      var value = data.getUint32(offset);
      offset += 4;
      return value;
    }
    function getUint64() {
      var low = data.getUint32(offset + 4);
      var high = data.getUint32(offset);
      offset += 8;
      return high * 0x100000000 + low;
    }
    function getInt8() {
      var value = data.getInt8(offset);
      offset += 1;
      return value;
    }
    function getInt16() {
      var value = data.getInt16(offset);
      offset += 2;
      return value;
    }
    function getInt32() {
      var value = data.getInt32(offset);
      offset += 4;
      return value;
    }
    function getInt64() {
      var low = data.getUint32(offset + 4);
      var high = data.getInt32(offset);
      offset += 8;
      return high * 0x100000000 + low;
    }
    function getFloat32() {
      var value = data.getFloat32(offset);
      offset += 4;
      return value;
    }
    function getFloat64() {
      var value = data.getFloat64(offset);
      offset += 8;
      return value;
    }
    function getRawString(length) {
      var bytes = [];
      for (var i = 0; i < length; i++) {
        bytes.push(getUint8());
      }
      return binaryToString(bytes);
    }
  }

  function encodeInternal(data, encoded) {
    var type = typeof data;
    if (data === null) {
      encoded.push([0xc0]); // nil
    } else if (type === 'boolean') {
      encoded.push(data ? [0xc3] : [0xc2]); // true, false
    } else if (type === 'number') {
      if (data === (data | 0)) { // integer
        if (data >= 0) {
          if (data < 0x80) { // positive fixnum
            encoded.push([data]);
          } else if (data < 0x100) { // uint8
            encoded.push([0xcc, data]);
          } else if (data < 0x10000) { // uint16
            encoded.push([0xcd, data >> 8, data & 0xff]);
          } else if (data < 0x100000000) { // uint32
            encoded.push([0xce, data >>> 24, data >>> 16 & 0xff, data >>> 8 & 0xff, data & 0xff]);
          } else { // uint64
            var high = data / 0x100000000;
            var low = data % 0x100000000;
            encoded.push([0xcf, high >>> 24, high >>> 16 & 0xff, high >>> 8 & 0xff, high & 0xff,
                                   low >>> 24, low >>> 16 & 0xff, low >>> 8 & 0xff, low & 0xff]);
          }
        } else {
          if (data >= -0x20) { // negative fixnum
            encoded.push([data + 0x100]);
          } else if (data >= -0x80) { // int8
            encoded.push([0xd0, data + 0x100]);
          } else if (data >= -0x8000) { // int16
            encoded.push([0xd1, data >> 8 & 0xff, data & 0xff]);
          } else if (data >= -0x80000000) { // int32
            encoded.push([0xd2, data >>> 24 & 0xff, data >>> 16 & 0xff, data >>> 8 & 0xff, data & 0xff]);
          } else { // int64
            var high = Math.floor(data / 0x100000000);
            var low = data % 0x100000000;
            encoded.push([0xd3, high >>> 24 & 0xff, high >>> 16 & 0xff, high >>> 8 & 0xff, high & 0xff,
                                   low >>> 24, low >>> 16 & 0xff, low >>> 8 & 0xff, low & 0xff]);
          }
        }
      } else { // float
        if (exports.useNativeBuffer) {
          var array = new Float64Array(1);
          array[0] = data;
          encoded.push(new Uint8Array(array.buffer));
        } else {
          encoded.push([0xcb].concat(float64ToBytes(data)));
        }
      }
    } else if (type === 'string') {
      var bytes = stringToBinary(data);
      var length = bytes.length;
      if (length < 0x20) { // fixraw
        encoded.push([0xa0 | length].concat(bytes));
      } else if (length < 0x10000) { // raw16
        encoded.push([0xda, length >> 8, length & 0xff].concat(bytes));
      } else { // raw32
        encoded.push([0xdb, length >>> 24, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff].concat(bytes));
      }
    } else if (Array.isArray(data)) {
      var length = data.length;
      if (length < 0x10) { // fixarray
        var header = [0x90 | length];
        encoded.push(header);
        for (var i = 0; i < length; i++) {
          encodeInternal(data[i], encoded);
        }
      } else if (length < 0x10000) { // array16
        encoded.push([0xdc, length >> 8, length & 0xff]);
        for (var i = 0; i < length; i++) {
          encodeInternal(data[i], encoded);
        }
      } else { // array32
        encoded.push([0xdd, length >>> 24, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]);
        for (var i = 0; i < length; i++) {
          encodeInternal(data[i], encoded);
        }
      }
    } else if (type === 'object') {
      var keys = Object.keys(data);
      var length = keys.length;
      if (length < 0x10) { // fixmap
        encoded.push([0x80 | length]);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          encodeInternal(key, encoded);
          encodeInternal(data[key], encoded);
        }
      } else if (length < 0x10000) { // map16
        encoded.push([0xde, length >> 8, length & 0xff]);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          encodeInternal(key, encoded);
          encodeInternal(data[key], encoded);
        }
      } else { // map32
        encoded.push([0xdf, length >>> 24, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]);
        for (var i = 0; i < length; i++) {
          var key = keys[i];
          encodeInternal(key, encoded);
          encodeInternal(data[key], encoded);
        }
      }
    } else if (exports.useNativeBuffer && data instanceof ArrayBuffer) {
      var bytes = new Uint8Array(data);
      var length = bytes.length;
      if (length < 0x10000) {
        encoded.push([0xc4, length >> 8, length & 0xff]);
      } else {
        encoded.push([0xc5, length >>> 24, length >>> 16 & 0xff, length >>> 8 & 0xff, length & 0xff]);
      }
      encoded.push(bytes);
    } else {
      throw new Error('Could not encode data of type ' + type);
    }
  }

  // Utilities for converting between strings and arrays of bytes
  function stringToBinary(string) {
    var bytes = [];
    for (var i = 0, ii = string.length; i < ii; i++) {
      var charCode = string.charCodeAt(i);
      if (charCode < 0x80) {
        bytes.push(charCode);
      } else if (charCode < 0x800) {
        bytes.push(0xc0 | charCode >> 6);
        bytes.push(0x80 | charCode & 0x3f);
      } else if (charCode < 0xd800 || charCode >= 0xe000) {
        bytes.push(0xe0 | charCode >> 12);
        bytes.push(0x80 | charCode >> 6 & 0x3f);
        bytes.push(0x80 | charCode & 0x3f);
      } else { // surrogate pair
        i++;
        charCode = ((charCode & 0x3ff) << 10) + (string.charCodeAt(i) & 0x3ff) + 0x10000;
        bytes.push(0xf0 | charCode >> 18);
        bytes.push(0x80 | charCode >> 12 & 0x3f);
        bytes.push(0x80 | charCode >> 6 & 0x3f);
        bytes.push(0x80 | charCode & 0x3f);
      }
    }
    return bytes;
  }

  function binaryToString(bytes) {
    var string = '';
    var i = 0;
    while (i < bytes.length) {
      var byte1 = bytes[i++];
      if (byte1 < 0x80) {
        string += String.fromCharCode(byte1);
      } else if (byte1 < 0xc0) {
        // continuation byte, ignore
      } else if (byte1 < 0xe0) {
        var byte2 = bytes[i++];
        string += String.fromCharCode(((byte1 & 0x1f) << 6) | (byte2 & 0x3f));
      } else if (byte1 < 0xf0) {
        var byte2 = bytes[i++];
        var byte3 = bytes[i++];
        string += String.fromCharCode(((byte1 & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f));
      } else {
        var byte2 = bytes[i++];
        var byte3 = bytes[i++];
        var byte4 = bytes[i++];
        var codepoint = ((byte1 & 0x07) << 18) | ((byte2 & 0x3f) << 12) | ((byte3 & 0x3f) << 6) | (byte4 & 0x3f);
        if (codepoint >= 0x10000) {
          codepoint -= 0x10000;
          string += String.fromCharCode(0xd800 + (codepoint >> 10));
          string += String.fromCharCode(0xdc00 + (codepoint & 0x3ff));
        } else {
          string += String.fromCharCode(codepoint);
        }
      }
    }
    return string;
  }

  function float64ToBytes(float) {
    var buffer = new ArrayBuffer(8);
    new DataView(buffer).setFloat64(0, float);
    var bytes = [];
    var uint8 = new Uint8Array(buffer);
    for (var i = 0; i < 8; i++) {
      bytes.push(uint8[i]);
    }
    return bytes;
  }

})(global);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
'use strict';

var util = require('./util');
var EventEmitter = require('eventemitter3');
var BinaryPack = require('./binarypack');
var Negotiator = require('./negotiator');
var Reliable = require('./reliable');

/**
 * Wraps a DataChannel between two Peers.
 * @param {string} peer - The peer ID of the remote peer
 * @param {Peer} provider - The Peer that provides this connection
 * @param {Object} [options] - Optional arguments for the connection
 * @param {string} [options.connectionId] - An ID to uniquely identify this connection
 * @param {*} [options.metadata] - Additional metadata to pass to the remote peer
 * @param {string} [options.label] - A label to easily identify the connection
 * @param {string} [options.serialization='binary'] - How to serialize data
 * @param {boolean} [options.reliable=false] - Whether to use reliable data transmission
 */
function DataConnection(peer, provider, options) {
  if (!(this instanceof DataConnection)) {
    return new DataConnection(peer, provider, options);
  }

  EventEmitter.call(this);

  options = util.extend({
    connectionId: DataConnection._idPrefix + util.randomToken(),
    metadata: {},
    label: '',
    serialization: 'binary',
    reliable: false
  }, options);

  this._peer = peer;
  this._provider = provider;
  this.options = options;
  this.id = options.connectionId;
  this.label = options.label;
  this.metadata = options.metadata;
  this.serialization = options.serialization;
  this.reliable = options.reliable;
  this.open = false;
  this.type = 'data';

  this._negotiator = new Negotiator(this);
  this._initialize();
}

util.inherits(DataConnection, EventEmitter);

DataConnection._idPrefix = 'dc_';

/** Called by the Negotiator when the DataChannel is ready. */
DataConnection.prototype._initialize = function() {
  var self = this;
  if (this.reliable) {
    this._reliable = new Reliable(this._provider._socket, this.id, this._peer);
    this._reliable.on('message', function(message) {
      self.emit('data', message);
    });
    this._reliable.on('open', function() {
      self.open = true;
      self.emit('open');
    });
    this._reliable.on('close', function() {
      self.close();
    });
  } else {
    this._negotiator.startConnection(
      this._provider._options.config,
      function(err, dc) {
        if (err) {
          self.emit('error', err);
          return;
        }
        self._dc = dc;
        self._configureDataChannel();
      }
    );
  }
};

/** Handles incoming messages on the DataChannel. */
DataConnection.prototype._configureDataChannel = function() {
  var self = this;
  this._dc.onopen = function() {
    self.open = true;
    self.emit('open');
  };
  this._dc.onmessage = function(e) {
    var data = e.data;
    if (self.serialization === 'binary' || self.serialization === 'binary-utf8') {
      data = BinaryPack.decode(data);
    } else if (self.serialization === 'json') {
      data = JSON.parse(data);
    }
    self.emit('data', data);
  };
  this._dc.onclose = function() {
    self.close();
  };
};

/**
 * Called by the Negotiator when the DataChannel is ready.
 * @param {RTCDataChannel} dc
 */
DataConnection.prototype.answer = function(dc) {
  var self = this;
  this._dc = dc;
  this._configureDataChannel();
};

/** Exposed functionality for users. */

/**
 * Closes the DataConnection.
 */
DataConnection.prototype.close = function() {
  if (this._reliable) {
    this._reliable.close();
  }
  if (this._dc) {
    this._dc.close();
  }
  this._negotiator.cleanup();
  this.open = false;
  this.emit('close');
};

/**
 * Sends data to the remote peer.
 * @param {*} data - The data to send
 */
DataConnection.prototype.send = function(data) {
  if (!this.open) {
    this.emit('error', new Error('Connection is not open. Cannot send data.'));
    return;
  }
  var self = this;
  if (this._reliable) {
    this._reliable.send(data);
  } else {
    if (this.serialization === 'binary' || this.serialization === 'binary-utf8') {
      data = BinaryPack.encode(data);
    } else if (this.serialization === 'json') {
      data = JSON.stringify(data);
    }
    try {
      this._dc.send(data);
    } catch (err) {
      self.emit('error', err);
    }
  }
};

/** Handles messages from the Peer. */
DataConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;
  switch (message.type) {
    case 'ANSWER':
      this._negotiator.handleSDP('answer', payload.sdp);
      break;
    case 'CANDIDATE':
      this._negotiator.handleCandidate(payload.candidate);
      break;
    default:
      console.warn('Unrecognized message type:', message.type, 'from peer:', this._peer);
      break;
  }
};

module.exports = DataConnection;

},{"./binarypack":2,"./eventemitter3":4,"./negotiator":7,"./reliable":8,"./util":10}],4:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still accessible in
  // some browsers like Aurora 7 and iPhone Safari. Not needed in Node.js though.
  // Removing this hack will break compatibility with those browsers.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];
  
  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Check if there is a listener for the given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean}
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        case 5: listeners[i].fn.call(listeners[i].context, a1, a2, a3, a4); break;
        case 6: listeners[i].fn.call(listeners[i].context, a1, a2, a3, a4, a5); break;
        default:
          for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if ('undefined' !== typeof module) {
  module.exports = EventEmitter;
}

},{}],5:[function(require,module,exports){
'use strict';

var Log = {
  logLevel: 0,
  setLogFunction: function(fn) {
    this.logFunction = fn;
  },
  log: function() {
    if (this.logLevel > 2) {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PEER:');
      if (this.logFunction) {
        this.logFunction.apply(this, copy);
      } else {
        console.log.apply(console, copy);
      }
    }
  },
  warn: function() {
    if (this.logLevel > 1) {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PEER:');
      if (this.logFunction) {
        this.logFunction.apply(this, copy);
      } else {
        console.warn.apply(console, copy);
      }
    }
  },
  error: function() {
    if (this.logLevel > 0) {
      var copy = Array.prototype.slice.call(arguments);
      copy.unshift('PEER:');
      if (this.logFunction) {
        this.logFunction.apply(this, copy);
      } else {
        console.error.apply(console, copy);
      }
    }
  }
};

module.exports = Log;

},{}],6:[function(require,module,exports){
'use strict';

var util = require('./util');
var EventEmitter = require('eventemitter3');
var Negotiator = require('./negotiator');

/**
 * Wraps a WebRTC video/voice call between two Peers.
 * @param {string} peer - The peer ID of the remote peer
 * @param {Peer} provider - The Peer that provides this connection
 * @param {Object} [options] - Optional arguments for the connection
 * @param {string} [options.connectionId] - An ID to uniquely identify this connection
 * @param {*} [options.metadata] - Additional metadata to pass to the remote peer
 * @param {MediaStream} [options.stream] - A MediaStream to send to the remote peer
 */
function MediaConnection(peer, provider, options) {
  if (!(this instanceof MediaConnection)) {
    return new MediaConnection(peer, provider, options);
  }

  EventEmitter.call(this);

  options = util.extend({
    connectionId: MediaConnection._idPrefix + util.randomToken(),
    metadata: {},
    stream: null
  }, options);

  this._peer = peer;
  this._provider = provider;
  this.options = options;
  this.id = options.connectionId;
  this.metadata = options.metadata;
  this.open = false;
  this.type = 'media';
  this.localStream = options.stream;

  this._negotiator = new Negotiator(this);
  this._initialize();
}

util.inherits(MediaConnection, EventEmitter);

MediaConnection._idPrefix = 'mc_';

/** Called by the Negotiator when the PeerConnection is ready. */
MediaConnection.prototype._initialize = function() {
  var self = this;
  this._negotiator.startConnection(
    this._provider._options.config,
    this.localStream,
    function(err, pc) {
      if (err) {
        self.emit('error', err);
        return;
      }
      self._pc = pc;
      self._configurePeerConnection();
    }
  );
};

/** Handles incoming messages on the PeerConnection. */
MediaConnection.prototype._configurePeerConnection = function() {
  var self = this;
  this._pc.oniceconnectionstatechange = function() {
    switch (self._pc.iceConnectionState) {
      case 'connected':
        self.open = true;
        self.emit('open');
        break;
      case 'disconnected':
      case 'failed':
        self.close();
        break;
    }
  };
  this._pc.onaddstream = function(e) {
    self.remoteStream = e.stream;
    self.emit('stream', e.stream);
  };
  this._pc.onremovestream = function() {
    self.close();
  };
};

/**
 * Called by the Negotiator when the PeerConnection is ready.
 * @param {RTCPeerConnection} pc
 */
MediaConnection.prototype.answer = function(pc) {
  var self = this;
  this._pc = pc;
  this._configurePeerConnection();
  this._negotiator.handleSDP('answer', this._provider._socket.id, function(err) {
    if (err) {
      self.emit('error', err);
      return;
    }
    self.open = true;
    self.emit('open');
  });
};

/** Exposed functionality for users. */

/**
 * Closes the MediaConnection.
 */
MediaConnection.prototype.close = function() {
  if (this._pc) {
    this._pc.close();
  }
  this._negotiator.cleanup();
  this.open = false;
  this.emit('close');
};

/** Handles messages from the Peer. */
MediaConnection.prototype.handleMessage = function(message) {
  var payload = message.payload;
  switch (message.type) {
    case 'ANSWER':
      this._negotiator.handleSDP('answer', payload.sdp);
      break;
    case 'CANDIDATE':
      this._negotiator.handleCandidate(payload.candidate);
      break;
    default:
      console.warn('Unrecognized message type:', message.type, 'from peer:', this._peer);
      break;
  }
};

module.exports = MediaConnection;

},{"./eventemitter3":4,"./negotiator":7,"./util":10}],7:[function(require,module,exports){
'use strict';

var util = require('./util');

/**
 * Handles all negotiations for a PeerConnection.
 * @param {DataConnection|MediaConnection} connection - The connection that owns this negotiator
 */
function Negotiator(connection) {
  this.connection = connection;
}

/** Creates an offer or answer. */
Negotiator.prototype.startConnection = function(config, stream, callback) {
  var self = this;
  util.createPeerConnection(config, function(err, pc) {
    if (err) {
      callback(err);
      return;
    }
    self.pc = pc;
    if (stream) {
      pc.addStream(stream);
    }
    util.createOffer(pc, function(err, offer) {
      if (err) {
        callback(err);
        return;
      }
      util.setLocalDescription(pc, offer, function(err) {
        if (err) {
          callback(err);
          return;
        }
        self._sendOffer(offer);
        callback(null, pc);
      });
    });
  });
};

/** Sends an offer to the remote peer. */
Negotiator.prototype._sendOffer = function(offer) {
  var payload = {
    sdp: offer,
    type: 'offer',
    connectionId: this.connection.id,
    metadata: this.connection.metadata,
    label: this.connection.label
  };
  if (this.connection.type === 'data') {
    payload.reliable = this.connection.reliable;
    payload.serialization = this.connection.serialization;
  }
  this.connection._provider._socket.send({
    type: 'OFFER',
    payload: payload,
    dst: this.connection._peer
  });
};

/** Handles an SDP. */
Negotiator.prototype.handleSDP = function(type, sdp, callback) {
  var self = this;
  if (type === 'offer') {
    util.setRemoteDescription(self.pc, sdp, function(err) {
      if (err) {
        if (callback) callback(err);
        return;
      }
      util.createAnswer(self.pc, function(err, answer) {
        if (err) {
          if (callback) callback(err);
          return;
        }
        util.setLocalDescription(self.pc, answer, function(err) {
          if (err) {
            if (callback) callback(err);
            return;
          }
          self._sendAnswer(answer);
          if (callback) callback(null);
        });
      });
    });
  } else if (type === 'answer') {
    util.setRemoteDescription(self.pc, sdp, callback);
  }
};

/** Sends an answer to the remote peer. */
Negotiator.prototype._sendAnswer = function(answer) {
  this.connection._provider._socket.send({
    type: 'ANSWER',
    payload: {
      sdp: answer,
      connectionId: this.connection.id
    },
    dst: this.connection._peer
  });
};

/** Handles a candidate. */
Negotiator.prototype.handleCandidate = function(candidate) {
  var self = this;
  util.addIceCandidate(self.pc, candidate, function(err) {
    if (err) {
      console.warn('Error adding candidate:', err);
    }
  });
};

/** Cleans up the Negotiator. */
Negotiator.prototype.cleanup = function() {
  if (this.pc) {
    this.pc.close();
    this.pc = null;
  }
};

module.exports = Negotiator;

},{"./util":10}],8:[function(require,module,exports){
'use strict';

var util = require('./util');
var EventEmitter = require('eventemitter3');
var BinaryPack = require('./binarypack');

/**
 * Provides reliable message delivery for DataConnections.
 * @param {Socket} socket - The socket to send messages through
 * @param {string} connectionId - The ID of the DataConnection
 * @param {string} peer - The ID of the remote peer
 */
function Reliable(socket, connectionId, peer) {
  if (!(this instanceof Reliable)) {
    return new Reliable(socket, connectionId, peer);
  }

  EventEmitter.call(this);

  this._socket = socket;
  this._connectionId = connectionId;
  this._peer = peer;
  this._messageQueue = {};
  this._messageNumber = 0;
  this._receivedMessages = {};
  this._maxBufferSize = 256 * 1024; // 256KB
  this._bufferSize = 0;
  this._isOpen = false;

  this._initialize();
}

util.inherits(Reliable, EventEmitter);

/** Initializes the Reliable instance. */
Reliable.prototype._initialize = function() {
  var self = this;
  this._socket.on('message', function(data) {
    if (data.type === 'RELIABLE' && data.payload.connectionId === self._connectionId) {
      self._handleMessage(data.payload);
    }
  });
  this._isOpen = true;
  this.emit('open');
};

/** Handles incoming reliable messages. */
Reliable.prototype._handleMessage = function(payload) {
  var type = payload.type;
  var number = payload.number;
  var data = payload.data;

  switch (type) {
    case 'DATA':
      // Send ACK
      this._send({
        type: 'ACK',
        number: number
      });
      // Deliver data if not already delivered
      if (!this._receivedMessages[number]) {
        this._receivedMessages[number] = true;
        var decoded = BinaryPack.decode(data);
        this.emit('data', decoded);
        // Cleanup old messages
        this._cleanupReceived();
      }
      break;
    case 'ACK':
      // Remove from queue
      if (this._messageQueue[number]) {
        this._bufferSize -= this._messageQueue[number].byteLength || this._messageQueue[number].length;
        delete this._messageQueue[number];
      }
      break;
    case 'NACK':
      // Resend message
      if (this._messageQueue[number]) {
        this._send(this._messageQueue[number]);
      }
      break;
  }
};

/** Sends a reliable message. */
Reliable.prototype._send = function(message) {
  this._socket.send({
    type: 'RELIABLE',
    payload: util.extend({
      connectionId: this._connectionId
    }, message),
    dst: this._peer
  });
};

/** Cleans up received messages buffer. */
Reliable.prototype._cleanupReceived = function() {
  var numbers = Object.keys(this._receivedMessages).map(Number).sort();
  if (numbers.length > 100) { // Keep last 100 messages
    for (var i = 0; i < numbers.length - 100; i++) {
      delete this._receivedMessages[numbers[i]];
    }
  }
};

/** Exposed functionality for users. */

/**
 * Sends data reliably.
 * @param {*} data - The data to send
 */
Reliable.prototype.send = function(data) {
  if (!this._isOpen) {
    this.emit('error', new Error('Connection is not open'));
    return;
  }

  var encoded = BinaryPack.encode(data);
  var size = encoded.byteLength || encoded.length;
  
  // Check buffer size
  if (this._bufferSize + size > this._maxBufferSize) {
    this.emit('error', new Error('Buffer overflow'));
    return;
  }

  var number = this._messageNumber++;
  var message = {
    type: 'DATA',
    number: number,
    data: encoded
  };

  this._messageQueue[number] = message;
  this._bufferSize += size;
  this._send(message);

  // Set up retransmission timer
  var self = this;
  setTimeout(function() {
    if (self._messageQueue[number]) {
      self._send(message);
    }
  }, 1000);
};

/**
 * Closes the reliable connection.
 */
Reliable.prototype.close = function() {
  this._isOpen = false;
  this._messageQueue = {};
  this._receivedMessages = {};
  this._bufferSize = 0;
  this.emit('close');
};

module.exports = Reliable;

},{"./binarypack":2,"./eventemitter3":4,"./util":10}],9:[function(require,module,exports){
'use strict';

var util = require('./util');
var EventEmitter = require('eventemitter3');

/**
 * Manages socket connections to the PeerServer.
 * @param {boolean} secure - Whether to use a secure connection
 * @param {string} host - The host of the PeerServer
 * @param {number} port - The port of the PeerServer
 * @param {string} path - The path of the PeerServer
 * @param {string} key - The API key
 * @param {string} token - The session token
 */
function Socket(secure, host, port, path, key, token) {
  if (!(this instanceof Socket)) {
    return new Socket(secure, host, port, path, key, token);
  }

  EventEmitter.call(this);

  this._secure = secure;
  this._host = host;
  this._port = port;
  this._path = path;
  this._key = key;
  this._token = token;
  this._id = null;
  this._messagesQueue = [];
  this._ws = null;
  this._reconnectTimer = null;
  this._reconnectAttempts = 0;
  this._maxReconnectAttempts = 5;
}

util.inherits(Socket, EventEmitter);

/** Starts the socket connection. */
Socket.prototype.start = function(id) {
  var self = this;
  var protocol = this._secure ? 'wss://' : 'ws://';
  var url = protocol + this._host + ':' + this._port + this._path + 'peerjs?key=' + this._key + '&id=' + (id || '') + '&token=' + this._token;
  
  this._ws = new WebSocket(url);
  
  this._ws.onopen = function() {
    self._reconnectAttempts = 0;
    self.emit('open');
  };
  
  this._ws.onmessage = function(event) {
    var data;
    try {
      data = JSON.parse(event.data);
    } catch (e) {
      console.error('Invalid JSON received:', event.data);
      return;
    }
    self.emit('message', data);
  };
  
  this._ws.onclose = function(event) {
    self.emit('disconnected');
    self._reconnect(id);
  };
  
  this._ws.onerror = function(error) {
    self.emit('error', error);
  };
};

/** Attempts to reconnect. */
Socket.prototype._reconnect = function(id) {
  var self = this;
  
  if (this._reconnectAttempts >= this._maxReconnectAttempts) {
    this.emit('close');
    return;
  }
  
  this._reconnectAttempts++;
  var delay = Math.min(1000 * Math.pow(2, this._reconnectAttempts), 30000);
  
  this._reconnectTimer = setTimeout(function() {
    self.start(id);
  }, delay);
};

/** Sends a message through the socket. */
Socket.prototype.send = function(data) {
  if (this._ws && this._ws.readyState === WebSocket.OPEN) {
    this._ws.send(JSON.stringify(data));
  } else {
    this._messagesQueue.push(data);
  }
};

/** Closes the socket. */
Socket.prototype.close = function() {
  if (this._reconnectTimer) {
    clearTimeout(this._reconnectTimer);
    this._reconnectTimer = null;
  }
  if (this._ws) {
    this._ws.close();
    this._ws = null;
  }
  this._messagesQueue = [];
};

module.exports = Socket;

},{"./eventemitter3":4,"./util":10}],10:[function(require,module,exports){
'use strict';

var util = {};

/** Cloud server configuration. */
util.CLOUD_HOST = '0.peerjs.com';
util.CLOUD_PORT = 443;

/** Generates a random token. */
util.randomToken = function() {
  return Math.random().toString(36).substr(2);
};

/** Default WebRTC configuration. */
util.defaultConfig = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:global.stun.twilio.com:3478' }
  ],
  sdpSemantics: 'unified-plan'
};

/** Extends an object with properties from another. */
util.extend = function(destination, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
};

/** Inherits prototype properties from a parent constructor. */
util.inherits = function(child, parent) {
  function Temp() {}
  Temp.prototype = parent.prototype;
  child.prototype = new Temp();
  child.prototype.constructor = child;
};

/** Creates a WebRTC PeerConnection. */
util.createPeerConnection = function(config, callback) {
  var pc;
  try {
    pc = new RTCPeerConnection(config);
  } catch (err) {
    callback(err);
    return;
  }
  callback(null, pc);
};

/** Creates an SDP offer. */
util.createOffer = function(pc, callback) {
  pc.createOffer(function(offer) {
    callback(null, offer);
  }, function(err) {
    callback(err);
  });
};

/** Creates an SDP answer. */
util.createAnswer = function(pc, callback) {
  pc.createAnswer(function(answer) {
    callback(null, answer);
  }, function(err) {
    callback(err);
  });
};

/** Sets the local description. */
util.setLocalDescription = function(pc, desc, callback) {
  pc.setLocalDescription(desc, function() {
    callback(null);
  }, function(err) {
    callback(err);
  });
};

/** Sets the remote description. */
util.setRemoteDescription = function(pc, desc, callback) {
  pc.setRemoteDescription(desc, function() {
    callback(null);
  }, function(err) {
    callback(err);
  });
};

/** Adds an ICE candidate. */
util.addIceCandidate = function(pc, candidate, callback) {
  pc.addIceCandidate(candidate, function() {
    if (callback) callback(null);
  }, function(err) {
    if (callback) callback(err);
  });
};

module.exports = util;
},{}]},{},[1])(1)
});
